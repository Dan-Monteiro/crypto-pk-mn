<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Crypto Pac-Man</title>
  <style>
    :root {
      --bg-color: #1a0510;
      --wall-color: #ffe8f2;
      --text-color: #ffe8f2;
    }

    body {
      margin: 0;
      padding: 0;
      background-color: var(--bg-color);
      color: var(--text-color);
      font-family: 'Courier New', Courier, monospace;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
    }

    #app {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      /* Zoom/Scale the game to fit height */
      height: 90vh;
      aspect-ratio: 448/550;
      /* Approx ratio including UI */
    }

    canvas {
      border: 2px solid var(--wall-color);
      box-shadow: 0 0 10px var(--wall-color);
      background-color: #000;
      width: 100%;
      height: auto;
      image-rendering: pixelated;
      /* Keep crisp */
    }

    #ui {
      margin-top: 10px;
      width: 100%;
      display: flex;
      justify-content: space-between;
      font-size: 20px;
      /* Scaled relative to container */
      font-weight: bold;
    }

    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      pointer-events: none;
      /* Let clicks pass through to canvas if needed */
      z-index: 10;
    }

    .ghosty-text {
      font-family: 'Courier New', Courier, monospace;
      font-size: 40px;
      color: #f7931a;
      /* Bitcoin Orange */
      text-align: center;
      /* White border effect using text-shadow */
      text-shadow:
        -1px -1px 0 #fff,
        1px -1px 0 #fff,
        -1px 1px 0 #fff,
        1px 1px 0 #fff,
        0 0 10px #f7931a,
        /* Glow matches text */
        0 0 20px #f7931a;
      animation: float 2s ease-in-out infinite;
    }

    @keyframes float {

      0%,
      100% {
        transform: translateY(0);
      }

      50% {
        transform: translateY(-10px);
      }
    }
  </style>
</head>

<body>
  <div id="app">
    <canvas id="gameCanvas"></canvas>
    <div id="overlay">
      <div id="message" class="ghosty-text">PRESS SPACE<br>TO START</div>
    </div>
    <div id="ui">
      <div id="score">SCORE: <span id="scoreValue">0</span></div>
      <div id="level">LEVEL: <span id="levelValue">1</span></div>
    </div>
  </div>
  <script>
    // Sound Manager
    class SoundManager {
      constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.musicInterval = null;
      }

      playTone(freq, type, duration) {
        if (this.ctx.state === 'suspended') this.ctx.resume();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
      }

      playEat() {
        this.playTone(400, 'sine', 0.1);
      }

      playPower() {
        this.playTone(200, 'square', 0.3);
        setTimeout(() => this.playTone(300, 'square', 0.3), 100);
      }

      playStart() {
        this.playTone(440, 'square', 0.2);
        setTimeout(() => this.playTone(554, 'square', 0.2), 200);
        setTimeout(() => this.playTone(659, 'square', 0.4), 400);
      }

      playDie() {
        this.playTone(200, 'sawtooth', 0.5);
        setTimeout(() => this.playTone(100, 'sawtooth', 0.5), 200);
      }

      playLevelUp() {
        this.playTone(523.25, 'square', 0.1); // C5
        setTimeout(() => this.playTone(659.25, 'square', 0.1), 100); // E5
        setTimeout(() => this.playTone(783.99, 'square', 0.1), 200); // G5
        setTimeout(() => this.playTone(1046.50, 'square', 0.3), 300); // C6
      }

      stopMusic() {
        if (this.musicInterval) {
          clearInterval(this.musicInterval);
          this.musicInterval = null;
        }
      }

      playLobbyMusic() {
        this.stopMusic();
        const notes = [
          { f: 261.63, d: 0.2 }, { f: 329.63, d: 0.2 }, { f: 392.00, d: 0.2 }, { f: 523.25, d: 0.4 }, // C Major Arp
          { f: 392.00, d: 0.2 }, { f: 329.63, d: 0.2 }, { f: 261.63, d: 0.4 },
          { f: 293.66, d: 0.2 }, { f: 349.23, d: 0.2 }, { f: 440.00, d: 0.2 }, { f: 587.33, d: 0.4 }, // D Minor Arp
          { f: 440.00, d: 0.2 }, { f: 349.23, d: 0.2 }, { f: 293.66, d: 0.4 }
        ];
        let noteIndex = 0;

        const playNextNote = () => {
          const note = notes[noteIndex];
          this.playTone(note.f, 'triangle', 0.1);
          noteIndex = (noteIndex + 1) % notes.length;
        };

        this.musicInterval = setInterval(playNextNote, 300);
      }

      playGameMusic() {
        this.stopMusic();
        // Slow Tense Rhythmic Loop
        const notes = [
          { f: 80, d: 0.25 }, { f: 0, d: 0.1 }, { f: 80, d: 0.25 }, { f: 0, d: 0.1 },
          { f: 95, d: 0.25 }, { f: 0, d: 0.1 }, { f: 75, d: 0.25 }, { f: 0, d: 0.1 }
        ];
        let noteIndex = 0;

        const playNextNote = () => {
          const note = notes[noteIndex];
          if (note.f > 0) this.playTone(note.f, 'sawtooth', 0.2);
          noteIndex = (noteIndex + 1) % notes.length;
        };

        this.musicInterval = setInterval(playNextNote, 350);
      }

      playGameOverMusic() {
        this.stopMusic();
        // Sad/Descending "Loss" melody
        const notes = [
          { f: 440, d: 0.3 }, { f: 415, d: 0.3 }, { f: 392, d: 0.3 }, { f: 370, d: 0.6 }
        ];
        let noteIndex = 0;

        const playNextNote = () => {
          if (noteIndex >= notes.length) {
            clearInterval(this.musicInterval);
            return;
          }
          const note = notes[noteIndex];
          this.playTone(note.f, 'sawtooth', 0.3);
          noteIndex++;
        };

        this.musicInterval = setInterval(playNextNote, 400);
      }
    }

    // Maze Class
    class Maze {
      constructor(ctx) {
        this.ctx = ctx;
        this.tileSize = 16;
        this.wallColor = '#ffe8f2';

        this.btcImage = new Image();
        this.btcImage.src = 'btc.png';

        this.itemsRemaining = 0;
        this.reset();
      }

      reset() {
        // 1 = Wall, 0 = Dot, 2 = Power Pellet, 3 = Empty, 4 = Ghost House
        const initialMap = [
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1],
          [1, 2, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 2, 1],
          [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1],
          [1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1],
          [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 3, 1, 1, 3, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 3, 1, 1, 3, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1, 1, 0, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 0, 1, 1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1, 1, 0, 1, 1, 3, 1, 1, 1, 4, 4, 1, 1, 1, 3, 1, 1, 0, 1, 1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1, 1, 0, 1, 1, 3, 1, 4, 4, 4, 4, 4, 4, 1, 3, 1, 1, 0, 1, 1, 1, 1, 1, 1],
          [3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 1, 4, 4, 4, 4, 4, 4, 1, 3, 3, 3, 0, 3, 3, 3, 3, 3, 3],
          [1, 1, 1, 1, 1, 1, 0, 1, 1, 3, 1, 4, 4, 4, 4, 4, 4, 1, 3, 1, 1, 0, 1, 1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1, 1, 0, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 0, 1, 1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1, 1, 0, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 0, 1, 1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1, 1, 0, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 0, 1, 1, 1, 1, 1, 1],
          [1, 1, 1, 1, 1, 1, 0, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 0, 1, 1, 1, 1, 1, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1],
          [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1],
          [1, 2, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 2, 1],
          [1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1],
          [1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1],
          [1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1],
          [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
          [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
          [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
          [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];
        // Deep copy
        this.map = initialMap.map(row => [...row]);
        this.itemsRemaining = 0;
        for (let r = 0; r < this.map.length; r++) {
          for (let c = 0; c < this.map[r].length; c++) {
            if (this.map[r][c] === 0 || this.map[r][c] === 2) {
              this.itemsRemaining++;
            }
          }
        }
      }

      draw() {
        for (let row = 0; row < this.map.length; row++) {
          for (let col = 0; col < this.map[row].length; col++) {
            const tile = this.map[row][col];
            const x = col * this.tileSize;
            const y = row * this.tileSize;

            if (tile === 1) {
              this.ctx.fillStyle = this.wallColor;
              this.ctx.fillRect(x, y, this.tileSize, this.tileSize);
              this.ctx.strokeStyle = '#1a0510';
              this.ctx.lineWidth = 1;
              this.ctx.strokeRect(x, y, this.tileSize, this.tileSize);
            } else if (tile === 0) {
              // Cash ($)
              this.ctx.fillStyle = '#85bb65';
              this.ctx.font = '12px monospace';
              this.ctx.textAlign = 'center';
              this.ctx.textBaseline = 'middle';
              this.ctx.fillText('$', x + 8, y + 9);
            } else if (tile === 2) {
              // BTC Image
              if (this.btcImage.complete) {
                this.ctx.drawImage(this.btcImage, x, y, this.tileSize, this.tileSize);
              } else {
                // Fallback
                this.ctx.fillStyle = '#f7931a';
                this.ctx.beginPath();
                this.ctx.arc(x + 8, y + 8, 6, 0, Math.PI * 2);
                this.ctx.fill();
              }
            }
          }
        }
      }

      isWall(x, y) {
        const col = Math.floor(x / this.tileSize);
        const row = Math.floor(y / this.tileSize);
        if (row < 0 || row >= this.map.length || col < 0 || col >= this.map[0].length) {
          return true;
        }
        return this.map[row][col] === 1;
      }

      checkCollision(x, y) {
        const col = Math.floor((x + this.tileSize / 2) / this.tileSize);
        const row = Math.floor((y + this.tileSize / 2) / this.tileSize);

        if (row >= 0 && row < this.map.length && col >= 0 && col < this.map[0].length) {
          const tile = this.map[row][col];
          if (tile === 0 || tile === 2) {
            this.map[row][col] = 3;
            this.itemsRemaining--;
            return tile;
          }
        }
        return -1;
      }
    }

    // Pacman Class
    class Pacman {
      constructor(x, y, tileSize) {
        this.startX = x;
        this.startY = y;
        this.tileSize = tileSize;
        this.radius = tileSize / 2 - 2;
        this.speed = 100;
        this.reset();

        document.addEventListener('keydown', (e) => this.handleInput(e));
      }

      reset() {
        this.x = this.startX;
        this.y = this.startY;
        this.currentDir = { x: 0, y: 0 };
        this.nextDir = { x: 0, y: 0 };
        this.mouthOpen = 0;
        this.mouthSpeed = 10;
        this.mouthOpening = true;
      }

      handleInput(e) {
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].indexOf(e.code) > -1) {
          e.preventDefault();
        }

        switch (e.code) {
          case 'ArrowUp': this.nextDir = { x: 0, y: -1 }; break;
          case 'ArrowDown': this.nextDir = { x: 0, y: 1 }; break;
          case 'ArrowLeft': this.nextDir = { x: -1, y: 0 }; break;
          case 'ArrowRight': this.nextDir = { x: 1, y: 0 }; break;
        }
      }

      update(deltaTime, maze) {
        if (this.nextDir.x !== 0 || this.nextDir.y !== 0) {
          if (this.canMove(this.x, this.y, this.nextDir, maze)) {
            this.currentDir = this.nextDir;
            this.nextDir = { x: 0, y: 0 };
          }
        }

        if (this.canMove(this.x, this.y, this.currentDir, maze)) {
          this.x += this.currentDir.x * this.speed * deltaTime;
          this.y += this.currentDir.y * this.speed * deltaTime;

          if (this.x < -this.tileSize) this.x = maze.map[0].length * this.tileSize;
          if (this.x > maze.map[0].length * this.tileSize) this.x = -this.tileSize;
        }

        if (this.mouthOpening) {
          this.mouthOpen += this.mouthSpeed * deltaTime;
          if (this.mouthOpen > 0.2) this.mouthOpening = false;
        } else {
          this.mouthOpen -= this.mouthSpeed * deltaTime;
          if (this.mouthOpen < 0) this.mouthOpening = true;
        }
      }

      canMove(x, y, dir, maze) {
        const nextX = x + dir.x * (this.tileSize / 2);
        const nextY = y + dir.y * (this.tileSize / 2);
        const centerX = nextX + this.tileSize / 2;
        const centerY = nextY + this.tileSize / 2;
        return !maze.isWall(centerX, centerY);
      }

      draw(ctx) {
        ctx.fillStyle = '#FFFF00';
        ctx.beginPath();

        const cx = this.x + this.tileSize / 2;
        const cy = this.y + this.tileSize / 2;

        let angle = 0;
        if (this.currentDir.x === 1) angle = 0;
        if (this.currentDir.x === -1) angle = Math.PI;
        if (this.currentDir.y === 1) angle = Math.PI / 2;
        if (this.currentDir.y === -1) angle = -Math.PI / 2;

        ctx.arc(cx, cy, this.radius, angle + this.mouthOpen * Math.PI, angle + (2 - this.mouthOpen) * Math.PI);
        ctx.lineTo(cx, cy);
        ctx.fill();
      }
    }

    // Ghost Class
    class Ghost {
      constructor(x, y, tileSize, color) {
        this.startX = x;
        this.startY = y;
        this.x = x;
        this.y = y;
        this.tileSize = tileSize;
        this.color = color;
        this.speed = 80;
        this.dir = { x: 1, y: 0 };
        this.radius = tileSize / 2 - 2;
      }

      reset() {
        this.x = this.startX;
        this.y = this.startY;
        this.dir = { x: 1, y: 0 };
      }

      update(deltaTime, maze, pacman) {
        if (this.canMove(this.x, this.y, this.dir, maze)) {
          this.x += this.dir.x * this.speed * deltaTime;
          this.y += this.dir.y * this.speed * deltaTime;

          if (this.x < -this.tileSize) this.x = maze.map[0].length * this.tileSize;
          if (this.x > maze.map[0].length * this.tileSize) this.x = -this.tileSize;
        } else {
          this.changeDirection(maze);
        }

        if (Math.random() < 0.02) {
          this.changeDirection(maze);
        }
      }

      changeDirection(maze) {
        const dirs = [
          { x: 0, y: -1 },
          { x: 0, y: 1 },
          { x: -1, y: 0 },
          { x: 1, y: 0 }
        ];

        const validDirs = dirs.filter(d => this.canMove(this.x, this.y, d, maze));

        if (validDirs.length > 0) {
          this.dir = validDirs[Math.floor(Math.random() * validDirs.length)];
        } else {
          this.dir = { x: -this.dir.x, y: -this.dir.y };
        }
      }

      canMove(x, y, dir, maze) {
        const nextX = x + dir.x * (this.tileSize / 2);
        const nextY = y + dir.y * (this.tileSize / 2);
        const centerX = nextX + this.tileSize / 2;
        const centerY = nextY + this.tileSize / 2;
        return !maze.isWall(centerX, centerY);
      }

      draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath();

        const cx = this.x + this.tileSize / 2;
        const cy = this.y + this.tileSize / 2;

        ctx.arc(cx, cy - 2, this.radius, Math.PI, 0);
        ctx.lineTo(cx + this.radius, cy + this.radius);
        ctx.lineTo(cx - this.radius, cy + this.radius);
        ctx.fill();

        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(cx - 4, cy - 4, 3, 0, Math.PI * 2);
        ctx.arc(cx + 4, cy - 4, 3, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = 'blue';
        ctx.beginPath();
        ctx.arc(cx - 4 + this.dir.x * 2, cy - 4 + this.dir.y * 2, 1.5, 0, Math.PI * 2);
        ctx.arc(cx + 4 + this.dir.x * 2, cy - 4 + this.dir.y * 2, 1.5, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Game Class
    class Game {
      constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.lastTime = 0;

        this.canvas.width = 448;
        this.canvas.height = 496;

        this.maze = new Maze(this.ctx);
        this.pacman = new Pacman(14 * 16, 23 * 16, 16);
        this.sound = new SoundManager();

        this.ghosts = [
          new Ghost(13 * 16, 11 * 16, 16, 'red'),
          new Ghost(14 * 16, 11 * 16, 16, 'pink'),
          new Ghost(13 * 16, 13 * 16, 16, 'cyan'),
          new Ghost(14 * 16, 13 * 16, 16, 'orange')
        ];

        this.score = 0;
        this.level = 1;
        this.isRunning = false;
        this.isGameOver = false;

        this.draw();

        // We also add a one-time click listener to the BODY to ensure audio context starts
        // as soon as the user interacts with the page in any way.
        const startAudio = () => {
          if (this.sound.ctx.state === 'suspended') {
            this.sound.ctx.resume().then(() => {
              this.sound.playLobbyMusic();
            });
          } else {
            this.sound.playLobbyMusic();
          }
        };
        document.addEventListener('click', startAudio, { once: true });
        document.addEventListener('keydown', startAudio, { once: true });
      }

      showLobby() {
        this.isRunning = false;
        this.isGameOver = false;
        this.fullReset();
        this.draw();
        document.getElementById('overlay').style.display = 'flex';
        document.getElementById('message').innerHTML = 'PRESS SPACE<br>TO START';
        this.sound.playLobbyMusic();
      }

      fullReset() {
        this.score = 0;
        this.level = 1;
        document.getElementById('scoreValue').innerText = 0;
        document.getElementById('levelValue').innerText = 1;
        this.maze.reset();
        this.pacman.reset();
        // Reset ghosts to initial 4
        this.ghosts = [
          new Ghost(13 * 16, 11 * 16, 16, 'red'),
          new Ghost(14 * 16, 11 * 16, 16, 'pink'),
          new Ghost(13 * 16, 13 * 16, 16, 'cyan'),
          new Ghost(14 * 16, 13 * 16, 16, 'orange')
        ];
      }

      start() {
        if (this.isRunning) return;

        this.isRunning = true;
        this.isGameOver = false;
        document.getElementById('overlay').style.display = 'none'; // Hide overlay

        this.lastTime = performance.now();
        this.sound.playGameMusic(); // Switch to game music
        this.sound.playStart();
        requestAnimationFrame((timestamp) => this.gameLoop(timestamp));
        console.log('Game Started');
      }

      gameLoop(timestamp) {
        if (!this.isRunning) return;

        // Cap deltaTime to prevent huge jumps (max 0.1s)
        let deltaTime = (timestamp - this.lastTime) / 1000;
        if (deltaTime > 0.1) deltaTime = 0.1;

        this.lastTime = timestamp;

        this.update(deltaTime);
        this.draw();

        requestAnimationFrame((timestamp) => this.gameLoop(timestamp));
      }

      update(deltaTime) {
        this.pacman.update(deltaTime, this.maze);
        this.ghosts.forEach(ghost => ghost.update(deltaTime, this.maze, this.pacman));

        const item = this.maze.checkCollision(this.pacman.x, this.pacman.y);
        if (item !== -1) {
          if (item === 0) {
            this.score += 10;
            this.sound.playEat();
          } else if (item === 2) {
            this.score += 50;
            this.sound.playPower();
          }
          document.getElementById('scoreValue').innerText = this.score;

          // Check Level Complete
          if (this.maze.itemsRemaining === 0) {
            this.nextLevel();
          }
        }

        this.ghosts.forEach(ghost => {
          const dx = ghost.x - this.pacman.x;
          const dy = ghost.y - this.pacman.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance < 10) {
            this.gameOver();
          }
        });
      }

      nextLevel() {
        this.level++;
        document.getElementById('levelValue').innerText = this.level;
        this.sound.playLevelUp();

        this.maze.reset();
        this.pacman.reset();
        this.ghosts.forEach(g => g.reset());

        // Add new ghost
        const colors = ['purple', 'green', 'yellow', 'white'];
        const color = colors[(this.level - 2) % colors.length];
        // Spawn in ghost house
        this.ghosts.push(new Ghost(13 * 16, 14 * 16, 16, color));

        // Pause briefly? For now just continue
        this.isRunning = false;
        setTimeout(() => {
          this.isRunning = true;
          this.lastTime = performance.now();
          requestAnimationFrame((timestamp) => this.gameLoop(timestamp));
        }, 2000);
      }

      draw() {
        this.ctx.fillStyle = '#1a0510';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        this.maze.draw();
        this.pacman.draw(this.ctx);
        this.ghosts.forEach(ghost => ghost.draw(this.ctx));
      }

      gameOver() {
        this.isRunning = false;
        this.isGameOver = true;
        this.sound.playDie();
        setTimeout(() => this.sound.playGameOverMusic(), 1000); // Start tense game over music after death sound

        document.getElementById('overlay').style.display = 'flex';
        document.getElementById('message').innerHTML = 'GAME OVER<br><span style="font-size:20px">PRESS ANY KEY</span>';
      }
    }

    window.addEventListener('DOMContentLoaded', () => {
      const game = new Game('gameCanvas');
      game.showLobby(); // Show lobby initially

      document.addEventListener('keydown', (e) => {
        if (game.isGameOver) {
          // If Game Over, any key returns to Lobby
          e.preventDefault();
          game.showLobby();
        } else if (!game.isRunning) {
          // If in Lobby, Space starts the game
          if (e.code === 'Space') {
            e.preventDefault();
            game.start();
          }
        }
      });
    });
  </script>
</body>

</html>